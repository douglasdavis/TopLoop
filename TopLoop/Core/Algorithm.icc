/// Inline functions for TL::Algorithm

inline void TL::Algorithm::setIsData() {
  m_isMC = false;
}

inline void TL::Algorithm::setIsSystematic() {
  m_isNominal = false;
}

inline void TL::Algorithm::turnOffTTRVWarning() {
  m_showTTRVwarning = false;
}

inline std::shared_ptr<TL::FileManager> TL::Algorithm::fileManager() {
  return m_fm;
}

inline std::shared_ptr<TTreeReader> TL::Algorithm::reader() {
  return m_reader;
}

inline std::shared_ptr<TTreeReader> TL::Algorithm::weightsReader() {
  return m_weightsReader;
}

inline void TL::Algorithm::setFileManager(std::shared_ptr<TL::FileManager> fm) {
  m_fm = fm;
  m_totalEntries = m_fm->rootChain()->GetEntries();
}

template<typename T>
inline std::shared_ptr<T>
TL::Algorithm::setupTreeVar(std::shared_ptr<TTreeReader> reader, const char* name, const char* tree_name) {
  using namespace msgAlgorithm;
  if ( !(ignoreList().empty()) && std::find(ignoreList().begin(),ignoreList().end(),name) != ignoreList().end() ) {
    return nullptr;
  }
  if ( reader->GetTree() == nullptr ) {
    if ( m_showTTRVwarning ) {
      ANA_MSG_INFO(name << " branch trying to link to a null tree! tree_name: " << tree_name);
    }
    return nullptr;
  }
  if ( reader->GetTree()->GetListOfBranches()->FindObject(name) != nullptr ) {
    return std::make_shared<T>(*reader,name);
  }
  else {
    if ( m_showTTRVwarning ) {
      ANA_MSG_INFO(name << " branch not found in the tree! If you try to access it, you will crash");
    }
    return nullptr;
  }
}
