/// Inline functions for TL::Algorithm

inline bool TL::Algorithm::initCalled() const {
  return m_initCalled;
}

inline void TL::Algorithm::setIsData() {
  m_isMC = false;
}

inline void TL::Algorithm::setIsSystematic() {
  m_isNominal = false;
}

inline const TL::FileManager* TL::Algorithm::fileManager() const {
  return m_fm.get();
}

inline std::shared_ptr<TTreeReader> TL::Algorithm::reader() const {
  return m_reader;
}

inline std::shared_ptr<TTreeReader> TL::Algorithm::weightsReader() const {
  return m_weightsReader;
}

inline TL::StatusCode TL::Algorithm::setFileManager(std::unique_ptr<TL::FileManager> fm) {
  if ( fm == nullptr ) return TL::StatusCode::FAILURE;
  m_fm = std::move(fm);
  m_totalEntries = m_fm->rootChain()->GetEntries();
  return TL::StatusCode::SUCCESS;
}

template<typename T>
inline std::unique_ptr<T>
TL::Algorithm::setupBranch(std::shared_ptr<TTreeReader> reader, const char* name, const char* tree_name) {
  if ( !(ignoreList().empty()) && std::find(ignoreList().begin(),ignoreList().end(),name) != ignoreList().end() ) {
    return nullptr;
  }
  if ( reader->GetTree() == nullptr ) {
    logger()->debug("{} branch trying to link to a null tree! tree name: {}", name, tree_name);
    return nullptr;
  }
  if ( reader->GetTree()->GetListOfBranches()->FindObject(name) != nullptr ) {
    return std::make_unique<T>(*reader,name);
  }
  else {
    logger()->debug("{} branch not found in the tree! use will crash!", name);
    return nullptr;
  }
}

inline bool TL::Algorithm::isMC() const {
  return m_isMC;
}

inline bool TL::Algorithm::isData() const {
  return !m_isMC;
}

inline bool TL::Algorithm::isNominal() const {
  return m_isNominal;
}

inline bool TL::Algorithm::isSystematic() const {
  return !m_isNominal;
}
